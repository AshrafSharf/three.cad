emcc  ./wasm/solver.c ./wasm/libslvs.a -L./wasm/ -lslvs -o ./dist/solver.js -s TOTAL_MEMORY=134217728 -s EXPORTED_FUNCTIONS='[_main, _solver, _free]'



int solver(int nLines, float *ptr)
{
  // for (int i=0; i<nLines ;i++) {
  //   printf("%f\n",*ptr++);
  // }
  float *buf_pt_start = ptr;

  Slvs_hGroup g;
  double qw, qx, qy, qz;

  g = 1;
  /* First, we create our workplane. Its origin corresponds to the origin
     * of our base frame (x y z) = (0 0 0) */
  sys.param[sys.params++] = Slvs_MakeParam(1, g, 0.0);
  sys.param[sys.params++] = Slvs_MakeParam(2, g, 0.0);
  sys.param[sys.params++] = Slvs_MakeParam(3, g, 0.0);
  sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3);
  /* and it is parallel to the xy plane, so it has basis vectors (1 0 0)
     * and (0 1 0). */
  Slvs_MakeQuaternion(1, 0, 0,
                      0, 1, 0, &qw, &qx, &qy, &qz);
  sys.param[sys.params++] = Slvs_MakeParam(4, g, qw);
  sys.param[sys.params++] = Slvs_MakeParam(5, g, qx);
  sys.param[sys.params++] = Slvs_MakeParam(6, g, qy);
  sys.param[sys.params++] = Slvs_MakeParam(7, g, qz);
  sys.entity[sys.entities++] = Slvs_MakeNormal3d(102, g, 4, 5, 6, 7);

  sys.entity[sys.entities++] = Slvs_MakeWorkplane(200, g, 101, 102);

  /* Now create a second group. We'll solve group 2, while leaving group 1
     * constant; so the workplane that we've created will be locked down,
     * and the solver can't move it. */
  g = 2;
  /* These points are represented by their coordinates (u v) within the
     * workplane, so they need only two parameters each. */

  Slvs_hParam h = 8;
  Slvs_hParam pt_id = 301;
  Slvs_hParam line_id = 400;
  Slvs_hParam con_id = 0;
  int ptStart = sys.params;
  for (int i = 0; i < nLines; i++)
  {
    sys.param[sys.params++] = Slvs_MakeParam(h++, g, (float)*ptr++);
    sys.param[sys.params++] = Slvs_MakeParam(h++, g, (float)*ptr++);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(pt_id++, g, 200, h - 2, h - 1);

    if (i > 0)
    {
      sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
          con_id++, g,
          SLVS_C_POINTS_COINCIDENT,
          200,
          0.0,
          pt_id - 1, pt_id - 2, 0, 0);
    }
    else
    {
      sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
          con_id++, g,
          SLVS_C_POINTS_COINCIDENT,
          200,
          0.0,
          pt_id - 1, 101, 0, 0);
    }

    printf("h:%i\n", h);

    sys.param[sys.params++] = Slvs_MakeParam(h++, g, (float)*ptr++);
    sys.param[sys.params++] = Slvs_MakeParam(h++, g, (float)*ptr++);

    sys.entity[sys.entities++] = Slvs_MakePoint2d(pt_id++, g, 200, h - 2, h - 1);

    sys.entity[sys.entities++] = Slvs_MakeLineSegment(line_id++, g,
                                                      200, pt_id - 1, pt_id - 2);

    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
        con_id++, g,
        SLVS_C_PT_PT_DISTANCE,
        200,
        30.0,
        pt_id - 1, pt_id - 2, 0, 0);
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
        con_id++, g,
        SLVS_C_VERTICAL,
        200,
        0.0,
        0, 0, line_id-1, 0);
  }

  /* If the solver fails, then ask it to report which constraints caused
     * the problem. */
  sys.calculateFaileds = 1;

  sys.dragged[0] = 10;
  sys.dragged[1] = 11;
  sys.dragged[2] = 14;
  sys.dragged[3] = 15;

  /* And solve. */
  Slvs_Solve(&sys, g);

  // printf("%i,wtf\n", sys.result);
  if (sys.result == SLVS_RESULT_OKAY)
  {
    printf("solved okay\n");

    for (int i = 0; i < nLines * 4; i++)
    {
      // *buf_pt_start++ = (float)sys.param[ptStart++].val;
      printf("%f\n", sys.param[ptStart++].val);
    }
  }
  else
  {
    int i;
    printf("solve failed: problematic constraints are:");
    for (i = 0; i < sys.faileds; i++)
    {
      printf(" %d", sys.failed[i]);
    }
    printf("\n");
    if (sys.result == SLVS_RESULT_INCONSISTENT)
    {
      printf("system inconsistent\n");
    }
    else
    {
      printf("system nonconvergent\n");
    }
  }
  sys.params = sys.constraints = sys.entities = 0;
  return 0;
}